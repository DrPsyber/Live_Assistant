<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Transcribe n Vibe</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Prompt:wght@300;400;500;600&display=swap" rel="stylesheet">
<style>
  :root {
    /* Primary Brand Colors */
    --beige: #E3E2E3;
    --lighter-gray: #454554;
    --darker-gray: #343541;
    --smart-green: #0EA27F;
    
    /* Secondary Brand Colors */
    --action-yellow: #FEDF0A;
    --smart-blue: #3536DF;
    --creative-purple: #41297D;
    --rebel-orange: #FE524E;
    
    /* UI Mapping */
    --bg-color: var(--beige);
    --text-color: var(--darker-gray);
    --primary-color: var(--smart-green);
    --primary-hover: var(--creative-purple);
    --secondary-bg: #f8f9fa;
    --border-color: var(--lighter-gray);
    --shadow-color: rgba(0, 0, 0, 0.1);
    --accent-color: var(--action-yellow);
    --radius: 12px;
    --inner-radius: 8px;
  }
  
  .dark-mode {
    --bg-color: var(--darker-gray);
    --text-color: var(--beige);
    --primary-color: var(--smart-green);
    --primary-hover: var(--smart-blue);
    --secondary-bg: var(--lighter-gray);
    --border-color: #2d2d2d;
    --shadow-color: rgba(0, 0, 0, 0.5);
    --accent-color: var(--action-yellow);
  }
  
  .dark-mode .logo {
    filter: invert(1);
  }
  
  body { 
    font-family: 'Prompt', -apple-system, BlinkMacSystemFont, sans-serif; 
    max-width: 650px; 
    margin: 20px auto; 
    line-height: 1.6; 
    background-color: var(--bg-color);
    color: var(--text-color);
    transition: all 0.3s ease;
    padding: 0 20px;
    font-size: 15px;
  }
  
  .logo-container {
    text-align: center;
    margin-bottom: 20px;
  }
  
  .logo {
    max-width: 280px;
    height: auto;
  }
  
  .header-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
  }
  
  .controls {
    display: flex;
    gap: 10px;
  }
  
  button { 
    padding: 10px 16px; 
    background: var(--primary-color); 
    color: white; 
    border: none; 
    border-radius: var(--inner-radius); 
    cursor: pointer; 
    font-family: 'Prompt', sans-serif;
    font-weight: 500;
    letter-spacing: 0.01em;
    transition: all 0.2s ease;
    font-size: 14px;
  }
  
  button:hover { 
    background: var(--primary-hover);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }
  
  .controls button {
    padding: 8px 12px;
    font-size: 1.1rem;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  pre { 
    background: var(--secondary-bg); 
    padding: 15px; 
    border-radius: var(--inner-radius); 
    white-space: pre-wrap; 
    margin-top: 15px;
    border: 1px solid var(--border-color);
    transition: background-color 0.3s;
    font-size: 14px;
    line-height: 1.6;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
  }
  
  h2, h3 {
    font-family: 'Montserrat', sans-serif;
    font-weight: 600;
    color: var(--primary-color);
  }
  
  /* Dialog styles */
  .dialog {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  
  .dialog-content {
    background-color: var(--bg-color);
    padding: 20px;
    border-radius: 5px;
    width: 80%;
    max-width: 400px;
    box-shadow: 0 2px 10px var(--shadow-color);
  }
  
  .dialog input {
    width: 100%;
    padding: 10px 12px;
    margin: 8px 0 16px;
    border: 1px solid var(--border-color);
    border-radius: var(--inner-radius);
    background-color: var(--bg-color);
    color: var(--text-color);
    font-size: 14px;
    transition: border-color 0.2s;
  }
  
  .dialog input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(14, 162, 127, 0.2);
  }
  
  .api-key-section {
    margin-bottom: 8px;
  }
  
  .api-key-section label {
    display: block;
    margin-bottom: 4px;
    font-weight: 500;
    font-size: 14px;
  }
  
  .dialog-buttons {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 15px;
  }
  
  .info-text {
    font-size: 14px;
    opacity: 0.8;
  }
  
  
  #api-key-status {
    margin-top: 10px;
    font-size: 14px;
    min-height: 20px;
  }
  
  .hidden {
    display: none;
  }
  
  @keyframes pulse {
    0% { opacity: 0.6; }
    50% { opacity: 1; }
    100% { opacity: 0.6; }
  }
  
  .pulsing {
    animation: pulse 1.5s infinite;
  }
  
  /* App description */
  .app-description {
    margin: -5px 0 20px;
    font-size: 15px;
    color: var(--text-color);
    opacity: 0.8;
  }

  /* Model selector styles */
  .options-row {
    display: flex;
    align-items: center;
    gap: 18px;
    margin-bottom: 18px;
    background: var(--secondary-bg);
    padding: 14px 18px;
    border-radius: var(--radius);
    box-shadow: 0 2px 8px rgba(0,0,0,0.04);
  }
  
  .recording-controls {
    display: flex;
    align-items: center;
  }
  
  .record-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
    padding: 12px 18px;
    background-color: var(--primary-color);
    transition: all 0.3s ease;
    border-radius: 28px;
    box-shadow: 0 4px 12px rgba(14, 162, 127, 0.25);
  }
  
  .record-btn:hover {
    transform: translateY(-2px);
    background-color: var(--primary-hover);
    box-shadow: 0 6px 16px rgba(65, 41, 125, 0.35);
  }
  
  .record-btn.active {
    background-color: var(--rebel-orange);
    box-shadow: 0 4px 12px rgba(254, 82, 78, 0.25);
  }
  
  .record-btn.active:hover {
    box-shadow: 0 6px 16px rgba(254, 82, 78, 0.35);
  }
  
  #end-transcription {
    background-color: var(--smart-blue);
    box-shadow: 0 4px 12px rgba(53, 54, 223, 0.25);
    margin-left: 8px;
  }
  
  #end-transcription:hover {
    background-color: var(--creative-purple);
    box-shadow: 0 6px 16px rgba(65, 41, 125, 0.35);
  }
  
  .model-selector {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  select {
    padding: 8px 12px;
    border-radius: var(--inner-radius);
    border: 1px solid var(--border-color);
    background-color: var(--bg-color);
    color: var(--text-color);
    font-family: 'Prompt', sans-serif;
    font-size: 14px;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%230EA27F' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    padding-right: 32px;
    cursor: pointer;
    transition: border-color 0.2s;
  }
  
  select:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(14, 162, 127, 0.2);
  }
  
  .transcription-box,
  .response-box {
    margin: 18px 0;
    border-radius: var(--radius);
    border: 1px solid var(--border-color);
    background-color: var(--secondary-bg);
    padding: 18px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    transition: all 0.3s ease;
  }
  
  .transcription-box:hover,
  .response-box:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
  }
  
  .transcription-box {
    border-left: 4px solid var(--smart-blue);
  }
  
  .response-box {
    border-left: 4px solid var(--smart-green);
  }
  
  .response-container {
    margin: 18px 0;
  }
  
  .response-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  
  .response-header .box-label {
    margin-bottom: 0;
  }
  
  .box-label {
    font-family: 'Montserrat', sans-serif;
    font-weight: 600;
    margin-bottom: 12px;
    color: var(--primary-color);
    font-size: 15px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  
  /* System prompt styles */
  .system-prompt-container {
    margin: 20px 0;
    padding: 18px;
    background-color: var(--secondary-bg);
    border-radius: var(--radius);
    border: 1px solid var(--border-color);
    border-left: 4px solid var(--creative-purple);
    box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    transition: all 0.3s ease;
  }
  
  .system-prompt-container:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
  }
  
  .prompt-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  
  .prompt-header label {
    font-weight: bold;
  }
  
  .preset-controls {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  
  .preset-controls button {
    padding: 6px 10px;
    font-size: 0.9rem;
  }
  
  #save-as-preset {
    font-size: 0.85rem;
  }
  
  #manage-presets {
    padding: 4px 8px;
    font-size: 1rem;
  }
  
  textarea {
    width: calc(100% - 20px);
    padding: 12px 10px;
    border-radius: var(--inner-radius);
    border: 1px solid var(--border-color);
    margin-bottom: 10px;
    background-color: var(--bg-color);
    color: var(--text-color);
    font-family: 'Prompt', sans-serif;
    resize: vertical;
    font-size: 14px;
    transition: border-color 0.2s ease;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05) inset;
    line-height: 1.5;
  }
  
  textarea:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(14, 162, 127, 0.2);
  }
  
  /* Preset management styles */
  .preset-list {
    margin: 15px 0;
    max-height: 300px;
    overflow-y: auto;
  }
  
  .preset-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    background-color: var(--bg-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    margin-bottom: 8px;
  }
  
  .preset-name {
    font-weight: bold;
  }
  
  .preset-actions {
    display: flex;
    gap: 5px;
  }
  
  .preset-actions button {
    padding: 4px 8px;
    font-size: 0.8rem;
  }
  
  /* History list styles */
  .history-container {
    margin-top: 30px;
  }
  
  .history-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  
  .clear-btn {
    padding: 6px 12px;
    font-size: 0.85rem;
    background-color: var(--rebel-orange);
  }
  
  .clear-btn:hover {
    background-color: #e63e39;
  }
  
  .history-list {
    margin-top: 10px;
  }
  
  .history-item {
    padding: 15px;
    background-color: var(--secondary-bg);
    border-radius: 5px;
    border: 1px solid var(--border-color);
    margin-bottom: 10px;
  }
  
  .history-item-objection {
    font-size: 0.85rem;
    opacity: 0.8;
    margin-bottom: 8px;
  }
  
  .history-item-response {
    font-weight: bold;
  }
  
  .history-item-meta {
    display: flex;
    justify-content: space-between;
    margin-top: 10px;
    font-size: 0.8rem;
    color: var(--text-color);
    opacity: 0.7;
  }
  
  .footer {
    margin-top: 40px;
    padding: 15px 0;
    text-align: center;
    border-top: 1px solid var(--border-color);
  }
  
  .footer a {
    color: var(--primary-color);
    text-decoration: none;
    font-weight: 500;
    transition: color 0.2s ease;
  }
  
  .footer a:hover {
    color: var(--primary-hover);
    text-decoration: underline;
  }
</style>

<div class="logo-container">
  <img src="Logo black.png" alt="AI Advantage Logo" class="logo">
</div>
<div class="header-controls">
  <h2>Transcribe n Vibe</h2>
  <div class="controls">
    <button id="theme-toggle" title="Toggle dark mode">üåì</button>
    <button id="settings-btn" title="Settings">‚öôÔ∏è</button>
  </div>
</div>
<div class="app-description">
  <p>Record objections and get AI-powered comeback responses in real-time</p>
</div>

<div class="options-row">
  <div class="recording-controls">
    <button id="toggle" class="record-btn">
      <span id="status-dot"></span>üé§ Start Listening
    </button>
    <div id="visualizer-container" style="margin-left: 10px; width: 120px; height: 30px; display: none; align-items: center; justify-content: center;"></div>
  </div>
</div>

<div class="transcription-box">
  <p class="box-label">üéôÔ∏è Transcription:</p>
  <pre id="lastObjection">Your speech will appear here...</pre>
</div>

<div class="system-prompt-container">
  <div class="prompt-header">
    <label for="system-prompt">Prompt:</label>
    <div class="preset-controls">
      <select id="preset-select">
        <option value="">-- Choose Preset --</option>
        <option value="executive-reframer">Executive Reframer</option>
        <option value="negotiation">Negotiation Expert</option>
      </select>
      <button id="save-as-preset" title="Save as new preset">Save As+</button>
      <button id="manage-presets" title="Manage presets">‚ãÆ</button>
    </div>
  </div>
  <textarea id="system-prompt" rows="3">You are a C-suite communication strategist specializing in reframing challenges as opportunities. Craft concise, authoritative responses that acknowledge objections while shifting perspective toward mutual benefit. Your goal is to maintain leadership presence while turning potential conflicts into collaborative solutions.</textarea>
  <button id="save-prompt">Save Prompt</button>
</div>

<div class="response-container">
  <div class="response-header">
    <p class="box-label">üí° AI Response:</p>
    <div class="model-selector">
      <label for="model-select">Model:</label>
      <select id="model-select">
        <option value="gpt-4o-2024-08-06">GPT-4o (Latest)</option>
        <option value="gpt-4o-mini-2024-07-18">GPT-4o Mini</option>
      </select>
    </div>
  </div>
  <div class="response-box">
    <pre id="reply">Responses will appear here...</pre>
  </div>
</div>

<!-- Preset Management Dialog -->
<div id="preset-dialog" class="dialog hidden">
  <div class="dialog-content">
    <h3>Manage Prompt Presets</h3>
    <div id="preset-list" class="preset-list">
      <!-- Presets will be loaded here -->
    </div>
    <div class="dialog-buttons">
      <button id="preset-dialog-close">Close</button>
    </div>
  </div>
</div>

<!-- New Preset Dialog -->
<div id="new-preset-dialog" class="dialog hidden">
  <div class="dialog-content">
    <h3>Save as New Preset</h3>
    <label for="new-preset-name">Preset Name:</label>
    <input type="text" id="new-preset-name" placeholder="Enter a name for this preset">
    <div class="dialog-buttons">
      <button id="new-preset-cancel">Cancel</button>
      <button id="new-preset-save">Save</button>
    </div>
    <p id="new-preset-status"></p>
  </div>
</div>

<div class="history-container">
  <div class="history-header">
    <h3>Response History</h3>
    <button id="clear-history" class="clear-btn" title="Clear all history">Clear History</button>
  </div>
  <div id="history-list" class="history-list"></div>
</div>

<!-- API Key Dialog -->
<div id="api-key-dialog" class="dialog hidden">
  <div class="dialog-content">
    <h3>API Key</h3>
    <p class="info-text">Your API key is stored locally in your browser.</p>
    
    <div class="api-key-section">
      <label for="openai-api-key-input">OpenAI API Key:</label>
      <input type="password" id="openai-api-key-input" placeholder="sk-..." />
    </div>
    
    <div class="dialog-buttons">
      <button id="api-key-save">Save</button>
      <button id="api-key-cancel">Cancel</button>
    </div>
    <p id="api-key-status"></p>
  </div>
</div>

<script>
// Initialize Speech Recognition
const Speech = window.SpeechRecognition || window.webkitSpeechRecognition;
const r = new Speech();
r.continuous = true;
r.interimResults = false;
let on = false;
let lastTranscript = '';

// Initialize app state
const appState = {
  responseHistory: [],
  systemPrompt: 'You are a C-suite communication strategist specializing in reframing challenges as opportunities. Craft concise, authoritative responses that acknowledge objections while shifting perspective toward mutual benefit. Your goal is to maintain leadership presence while turning potential conflicts into collaborative solutions.',
  selectedModel: 'gpt-4o-2024-08-06',
  presets: {
    'executive-reframer': {
      name: 'Executive Reframer',
      prompt: 'You are a C-suite communication strategist specializing in reframing challenges as opportunities. Craft concise, authoritative responses that acknowledge objections while shifting perspective toward mutual benefit. Your goal is to maintain leadership presence while turning potential conflicts into collaborative solutions.'
    },
    'negotiation': {
      name: 'Negotiation Expert',
      prompt: 'You are a skilled negotiation expert. Generate concise, tactical responses that redirect objections while building value. Focus on finding common ground, addressing concerns empathetically, and guiding toward agreement. Use data and logical framing to strengthen your position. Keep responses under 15 words and maintain a persuasive yet collaborative tone.'
    }
  }
};

// Initialize theme and settings
let audioProcessor = null;

document.addEventListener('DOMContentLoaded', () => {
  // Initialize audio processor if available
  if (typeof AudioProcessor === 'function') {
    try {
      audioProcessor = new AudioProcessor();
    } catch (e) {
      console.error('Error initializing AudioProcessor:', e);
    }
  }
  
  // Initialize UI state manager with error handling
  try {
    window.uiStateManager = new UIStateManager();
    console.log('UIStateManager initialized successfully');
  } catch (e) {
    console.error('Error initializing UIStateManager:', e);
  }
  
  // Load saved state
  loadSavedState();
  
  // No API key checks needed up front
  
  // Setup dark mode
  const savedTheme = localStorage.getItem('theme_mode');
  if (savedTheme === 'dark') {
    document.body.classList.add('dark-mode');
    
    // Set the toggle icon text
    const themeToggle = document.getElementById('theme-toggle');
    if (themeToggle) {
      themeToggle.textContent = 'üåì';
    }
  }
  
  // Set up event listeners with error handling
  const setupEventListeners = () => {
    try {
      // Theme toggle
      const themeToggle = document.getElementById('theme-toggle');
      if (themeToggle) {
        themeToggle.addEventListener('click', toggleTheme);
        console.log("Theme toggle button listener added");
      }
      
      // Settings button
      const settingsBtn = document.getElementById('settings-btn');
      if (settingsBtn) {
        settingsBtn.addEventListener('click', showApiKeyDialog);
        console.log("Settings button listener added");
      }
      
      // API key dialog buttons
      const apiKeySave = document.getElementById('api-key-save');
      if (apiKeySave) {
        apiKeySave.addEventListener('click', saveApiKey);
      }
      
      const apiKeyCancel = document.getElementById('api-key-cancel');
      if (apiKeyCancel) {
        apiKeyCancel.addEventListener('click', hideApiKeyDialog);
      }
      
      // Recording toggle
      const toggleBtn = document.getElementById('toggle');
      if (toggleBtn) {
        toggleBtn.addEventListener('click', toggleRecording);
        console.log("Toggle recording button listener added");
      }
      
      // Save prompt button
      const savePromptBtn = document.getElementById('save-prompt');
      if (savePromptBtn) {
        savePromptBtn.addEventListener('click', saveSystemPrompt);
      }
      
      // Model select
      const modelSelect = document.getElementById('model-select');
      if (modelSelect) {
        modelSelect.addEventListener('change', updateSelectedModel);
      }
    } catch (error) {
      console.error("Error setting up event listeners:", error);
    }
  };
  
  // Set up event listeners immediately and also with a small delay to ensure DOM is ready
  setupEventListeners();
  setTimeout(setupEventListeners, 500);
  
  // Preset management listeners
  try {
    const presetSelect = document.getElementById('preset-select');
    if (presetSelect) {
      presetSelect.addEventListener('change', loadSelectedPreset);
    }
    
    const saveAsPreset = document.getElementById('save-as-preset');
    if (saveAsPreset) {
      saveAsPreset.addEventListener('click', showNewPresetDialog);
    }
    
    const managePresets = document.getElementById('manage-presets');
    if (managePresets) {
      managePresets.addEventListener('click', showPresetManagerDialog);
    }
    
    const presetDialogClose = document.getElementById('preset-dialog-close');
    if (presetDialogClose) {
      presetDialogClose.addEventListener('click', hidePresetManagerDialog);
    }
    
    const newPresetCancel = document.getElementById('new-preset-cancel');
    if (newPresetCancel) {
      newPresetCancel.addEventListener('click', hideNewPresetDialog);
    }
    
    const newPresetSave = document.getElementById('new-preset-save');
    if (newPresetSave) {
      newPresetSave.addEventListener('click', saveNewPreset);
    }
    
    // History management
    const clearHistory = document.getElementById('clear-history');
    if (clearHistory) {
      clearHistory.addEventListener('click', clearResponseHistory);
    }
  } catch (error) {
    console.error("Error setting up preset/history listeners:", error);
  }
  
  // Close dialogs with Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      try {
        const apiKeyDialog = document.getElementById('api-key-dialog');
        const presetDialog = document.getElementById('preset-dialog');
        const newPresetDialog = document.getElementById('new-preset-dialog');
        
        if (apiKeyDialog && !apiKeyDialog.classList.contains('hidden')) {
          hideApiKeyDialog();
        } else if (presetDialog && !presetDialog.classList.contains('hidden')) {
          hidePresetManagerDialog();
        } else if (newPresetDialog && !newPresetDialog.classList.contains('hidden')) {
          hideNewPresetDialog();
        }
      } catch (error) {
        console.error("Error handling Escape key:", error);
      }
    }
  });
  
  // Render initial UI
  renderHistoryList();
  renderPresetList();
});

// Load app state from localStorage
function loadSavedState() {
  // Load system prompt
  const savedPrompt = localStorage.getItem('system_prompt');
  if (savedPrompt) {
    appState.systemPrompt = savedPrompt;
    document.getElementById('system-prompt').value = savedPrompt;
  }
  
  // Load selected model
  const savedModel = localStorage.getItem('selected_model');
  if (savedModel) {
    appState.selectedModel = savedModel;
    document.getElementById('model-select').value = savedModel;
  }
  
  // Load API keys
  const openaiKey = localStorage.getItem('openai_api_key') || '';
  const claudeKey = localStorage.getItem('claude_api_key') || '';
  
  // Load response history
  const savedHistory = localStorage.getItem('response_history');
  if (savedHistory) {
    try {
      appState.responseHistory = JSON.parse(savedHistory);
    } catch (e) {
      console.error('Error parsing saved history:', e);
      appState.responseHistory = [];
    }
  }
  
  // Load custom presets
  const savedPresets = localStorage.getItem('custom_presets');
  if (savedPresets) {
    try {
      const customPresets = JSON.parse(savedPresets);
      // Merge custom presets with default presets
      appState.presets = { ...appState.presets, ...customPresets };
      // Update the preset dropdown options
      setTimeout(updatePresetOptions, 0);
    } catch (e) {
      console.error('Error parsing saved presets:', e);
    }
  } else {
    // Make sure we have all default presets in the dropdown
    setTimeout(updatePresetOptions, 0);
  }
}

// Preset management functions
function renderPresetList() {
  const presetList = document.getElementById('preset-list');
  presetList.innerHTML = '';
  
  // Create preset items
  Object.entries(appState.presets).forEach(([id, preset]) => {
    const presetItem = document.createElement('div');
    presetItem.className = 'preset-item';
    
    const nameSpan = document.createElement('span');
    nameSpan.className = 'preset-name';
    nameSpan.textContent = preset.name;
    
    const actions = document.createElement('div');
    actions.className = 'preset-actions';
    
    const loadBtn = document.createElement('button');
    loadBtn.textContent = 'Load';
    loadBtn.addEventListener('click', () => {
      loadPreset(id);
      hidePresetManagerDialog();
    });
    
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete';
    
    // Don't allow deleting the default presets
    if (['executive-reframer', 'negotiation'].includes(id)) {
      deleteBtn.disabled = true;
      deleteBtn.title = 'Cannot delete default presets';
    } else {
      deleteBtn.addEventListener('click', () => deletePreset(id));
    }
    
    actions.appendChild(loadBtn);
    actions.appendChild(deleteBtn);
    
    presetItem.appendChild(nameSpan);
    presetItem.appendChild(actions);
    
    presetList.appendChild(presetItem);
  });
}

// Load a preset by ID
function loadPreset(presetId) {
  const preset = appState.presets[presetId];
  if (preset) {
    document.getElementById('system-prompt').value = preset.prompt;
    appState.systemPrompt = preset.prompt;
    localStorage.setItem('system_prompt', preset.prompt);
    
    // Update the dropdown selection
    document.getElementById('preset-select').value = presetId;
  }
}

// Load selected preset from dropdown
function loadSelectedPreset(e) {
  const presetId = e.target.value;
  if (presetId) {
    loadPreset(presetId);
  }
}

// Delete a preset
function deletePreset(presetId) {
  if (confirm(`Delete the preset "${appState.presets[presetId].name}"?`)) {
    // Remove from state
    delete appState.presets[presetId];
    
    // Filter out default presets and save custom ones
    const customPresets = {};
    Object.entries(appState.presets).forEach(([id, preset]) => {
      if (!['executive-reframer', 'negotiation'].includes(id)) {
        customPresets[id] = preset;
      }
    });
    
    // Save custom presets to localStorage
    localStorage.setItem('custom_presets', JSON.stringify(customPresets));
    
    // Update UI
    renderPresetList();
  }
}

// Show preset manager dialog
function showPresetManagerDialog() {
  renderPresetList();
  document.getElementById('preset-dialog').classList.remove('hidden');
}

// Hide preset manager dialog
function hidePresetManagerDialog() {
  document.getElementById('preset-dialog').classList.add('hidden');
}

// Show new preset dialog
function showNewPresetDialog() {
  document.getElementById('new-preset-name').value = '';
  document.getElementById('new-preset-status').textContent = '';
  document.getElementById('new-preset-dialog').classList.remove('hidden');
}

// Hide new preset dialog
function hideNewPresetDialog() {
  document.getElementById('new-preset-dialog').classList.add('hidden');
}

// Save a new preset
function saveNewPreset() {
  const nameInput = document.getElementById('new-preset-name');
  const statusElement = document.getElementById('new-preset-status');
  const name = nameInput.value.trim();
  
  if (!name) {
    statusElement.textContent = 'Please enter a name for the preset';
    statusElement.style.color = '#dc3545';
    return;
  }
  
  // Create a unique ID based on the name
  const id = 'custom-' + name.toLowerCase().replace(/[^a-z0-9]/g, '-');
  
  // Check if ID already exists
  if (appState.presets[id]) {
    statusElement.textContent = 'A preset with this name already exists';
    statusElement.style.color = '#dc3545';
    return;
  }
  
  // Create the new preset
  const newPreset = {
    name: name,
    prompt: document.getElementById('system-prompt').value
  };
  
  // Add to state
  appState.presets[id] = newPreset;
  
  // Filter out default presets and save custom ones
  const customPresets = {};
  Object.entries(appState.presets).forEach(([presetId, preset]) => {
    if (!['executive-reframer', 'negotiation'].includes(presetId)) {
      customPresets[presetId] = preset;
    }
  });
  
  // Save to localStorage
  localStorage.setItem('custom_presets', JSON.stringify(customPresets));
  
  // Update the preset dropdown options
  updatePresetOptions();
  
  // Show success message
  statusElement.textContent = 'Preset saved successfully';
  statusElement.style.color = '#28a745';
  
  // Close dialog after delay
  setTimeout(hideNewPresetDialog, 1500);
}

// Update preset dropdown options
function updatePresetOptions() {
  const select = document.getElementById('preset-select');
  
  // Clear existing options except the default one
  while (select.options.length > 1) {
    select.remove(1);
  }
  
  // Add all presets as options
  Object.entries(appState.presets).forEach(([id, preset]) => {
    const option = document.createElement('option');
    option.value = id;
    option.textContent = preset.name;
    select.appendChild(option);
  });
}

// Save system prompt
function saveSystemPrompt() {
  const promptText = document.getElementById('system-prompt').value.trim();
  if (promptText) {
    appState.systemPrompt = promptText;
    localStorage.setItem('system_prompt', promptText);
    
    // Show a flash message
    const saveBtn = document.getElementById('save-prompt');
    const originalText = saveBtn.textContent;
    saveBtn.textContent = 'Saved!';
    saveBtn.style.backgroundColor = '#28a745';
    
    setTimeout(() => {
      saveBtn.textContent = originalText;
      saveBtn.style.backgroundColor = '';
    }, 1500);
  }
}

// Update selected model
function updateSelectedModel(e) {
  appState.selectedModel = e.target.value;
  localStorage.setItem('selected_model', appState.selectedModel);
}

// Toggle dark/light theme
function toggleTheme() {
  document.body.classList.toggle('dark-mode');
  const isDark = document.body.classList.contains('dark-mode');
  localStorage.setItem('theme_mode', isDark ? 'dark' : 'light');
  
  const themeToggle = document.getElementById('theme-toggle');
  if (themeToggle) {
    if (isDark) {
      themeToggle.textContent = 'üåì';
    } else {
      themeToggle.textContent = 'üåì';
    }
  }
}

// API Key dialog functions
function showApiKeyDialog() {
  const dialog = document.getElementById('api-key-dialog');
  const openaiInput = document.getElementById('openai-api-key-input');
  
  const openaiKey = localStorage.getItem('openai_api_key') || '';
  
  openaiInput.value = openaiKey;
  
  dialog.classList.remove('hidden');
  setTimeout(() => openaiInput.focus(), 100);
}

function hideApiKeyDialog() {
  document.getElementById('api-key-dialog').classList.add('hidden');
}

function saveApiKey() {
  const openaiInput = document.getElementById('openai-api-key-input');
  const status = document.getElementById('api-key-status');
  
  const openaiKey = openaiInput.value.trim();
  let isValid = true;
  
  // Validate OpenAI key if provided
  if (openaiKey && !openaiKey.startsWith('sk-')) {
    status.textContent = 'Invalid OpenAI API key format. It should start with "sk-"';
    status.style.color = '#dc3545';
    isValid = false;
  }
  
  if (isValid) {
    if (openaiKey) {
      localStorage.setItem('openai_api_key', openaiKey);
    }
    
    status.textContent = 'API key saved successfully!';
    status.style.color = '#28a745';
    setTimeout(hideApiKeyDialog, 1000);
  }
}

// Toggle recording function
function toggleRecording() {
  const button = document.getElementById('toggle');
  
  if (on) {
    r.stop();
    on = false;
    button.textContent = 'üé§ Start Listening';
    button.classList.remove('active');
    document.getElementById('lastObjection').textContent = 'Your speech will appear here...';
    
    // Update UI state to ready with safe error handling
    try {
      if (window.uiStateManager && window.uiStateManager.states && window.uiStateManager.updateState) {
        window.uiStateManager.updateState(window.uiStateManager.states.READY);
      }
    } catch (e) {
      console.warn('Error updating UI state:', e);
    }
    
    // Stop visualizer when recording stops if available
    if (audioProcessor && typeof audioProcessor.stopVisualizer === 'function') {
      try {
        audioProcessor.stopVisualizer();
        // Hide the visualizer container
        const visualizerContainer = document.getElementById('visualizer-container');
        if (visualizerContainer) {
          visualizerContainer.style.display = 'none';
        }
      } catch (e) {
        console.error('Error stopping visualizer:', e);
      }
    }
  } else {
    // Start speech recognition
    try {
      r.start();
      on = true;
      button.textContent = 'üõë Stop Listening';
      button.classList.add('active');
      
      // Update UI state to listening with safe error handling
      try {
        if (window.uiStateManager && window.uiStateManager.states && window.uiStateManager.updateState) {
          window.uiStateManager.updateState(window.uiStateManager.states.LISTENING);
        }
      } catch (e) {
        console.warn('Error updating UI state:', e);
      }
      
      // Start audio context and visualizer if available
      if (audioProcessor && typeof audioProcessor.initAudioContext === 'function') {
        try {
          // Get audio stream for visualization
          navigator.mediaDevices.getUserMedia({ audio: true, video: false })
            .then(stream => {
              audioProcessor.initAudioContext()
                .then(() => {
                  const visualizerContainer = document.getElementById('visualizer-container');
                  if (visualizerContainer && typeof audioProcessor.setupVisualizer === 'function') {
                    // Make the container visible
                    visualizerContainer.style.display = 'flex';
                    audioProcessor.setupVisualizer(stream, visualizerContainer);
                  }
                })
                .catch(err => console.error('Failed to initialize audio context:', err));
            })
            .catch(err => console.error('Error accessing microphone:', err));
        } catch (e) {
          console.error('Error with audio processing:', e);
          // Continue with recording even if visualization fails
        }
      }
    } catch (e) {
      console.error('Error starting speech recognition:', e);
      alert('Failed to start speech recognition. Please try again.');
      
      // Update UI state to error with safe error handling
      try {
        if (window.uiStateManager && window.uiStateManager.states && window.uiStateManager.updateState) {
          window.uiStateManager.updateState(window.uiStateManager.states.ERROR);
        }
      } catch (e) {
        console.warn('Error updating UI state:', e);
      }
    }
  }
}

// Event handler for speech recognition results
r.onresult = async (e) => {
  const transcript = e.results[e.results.length-1][0].transcript.trim();
  document.getElementById('lastObjection').textContent = transcript;
  
  // If the transcript changed, generate a new response
  if (transcript !== lastTranscript) {
    lastTranscript = transcript;
    await generateResponse(transcript);
  }
};

// Render the history list
function renderHistoryList() {
  const historyList = document.getElementById('history-list');
  historyList.innerHTML = '';
  
  // Display history items from newest to oldest
  const sortedHistory = [...appState.responseHistory].reverse();
  
  sortedHistory.forEach(item => {
    const historyItem = document.createElement('div');
    historyItem.className = 'history-item';
    
    const objection = document.createElement('div');
    objection.className = 'history-item-objection';
    objection.textContent = 'üëÇ ' + item.objection;
    
    const response = document.createElement('div');
    response.className = 'history-item-response';
    response.textContent = 'üí° ' + item.response;
    
    const meta = document.createElement('div');
    meta.className = 'history-item-meta';
    
    const timestamp = document.createElement('span');
    timestamp.textContent = item.timestamp;
    
    const model = document.createElement('span');
    // Friendly display names for models
    let modelDisplay = item.model
      .replace('gpt-4o-2024-08-06', 'GPT-4o')
      .replace('gpt-4o-mini-2024-07-18', 'GPT-4o Mini');
    
    model.textContent = modelDisplay;
    
    meta.appendChild(timestamp);
    meta.appendChild(model);
    
    historyItem.appendChild(objection);
    historyItem.appendChild(response);
    historyItem.appendChild(meta);
    
    historyList.appendChild(historyItem);
  });
}

// Add a response to history
function addToHistory(objection, response, model) {
  const now = new Date();
  const timestamp = now.toLocaleTimeString();
  
  // Create history item
  const historyItem = {
    objection,
    response,
    model,
    timestamp
  };
  
  // Add to history
  appState.responseHistory.push(historyItem);
  
  // Limit history to 50 items
  if (appState.responseHistory.length > 50) {
    appState.responseHistory.shift();
  }
  
  // Save to localStorage
  localStorage.setItem('response_history', JSON.stringify(appState.responseHistory));
  
  // Update UI
  renderHistoryList();
}

// Clear response history
function clearResponseHistory() {
  if (confirm('Are you sure you want to clear all response history? This cannot be undone.')) {
    // Clear history in state
    appState.responseHistory = [];
    
    // Clear from localStorage
    localStorage.removeItem('response_history');
    
    // Update UI
    renderHistoryList();
    
    // Show confirmation
    const clearBtn = document.getElementById('clear-history');
    const originalText = clearBtn.textContent;
    clearBtn.textContent = 'Cleared!';
    
    setTimeout(() => {
      clearBtn.textContent = originalText;
    }, 1500);
  }
}

// Function to generate a response using OpenAI API
async function generateResponse(text) {
  const replyElement = document.getElementById('reply');
  
  // Show loading indicator
  replyElement.textContent = 'Thinking...';
  replyElement.classList.add('pulsing');
  
  // Update UI state to processing with safe error handling
  try {
    if (window.uiStateManager && window.uiStateManager.states && window.uiStateManager.updateState) {
      window.uiStateManager.updateState(window.uiStateManager.states.PROCESSING);
    }
  } catch (e) {
    console.warn('Error updating UI state:', e);
  }
  
  try {
    // Get selected model
    const model = appState.selectedModel;
    
    // Get system prompt
    const systemPrompt = appState.systemPrompt;
    
    // Generate response using OpenAI
    const reply = await generateOpenAIResponse(text, model, systemPrompt, replyElement);
    
    // Add to history after successful response
    addToHistory(text, reply, model);
    
    // Update UI state back to listening if still recording with safe error handling
    try {
      if (window.uiStateManager && window.uiStateManager.states && window.uiStateManager.updateState) {
        if (on) {
          window.uiStateManager.updateState(window.uiStateManager.states.LISTENING);
        } else {
          window.uiStateManager.updateState(window.uiStateManager.states.READY);
        }
      }
    } catch (e) {
      console.warn('Error updating UI state:', e);
    }
    
  } catch (error) {
    // Handle errors
    console.error('Error:', error);
    replyElement.classList.remove('pulsing');
    
    // Update UI state to error with safe error handling
    try {
      if (window.uiStateManager && window.uiStateManager.states && window.uiStateManager.updateState) {
        window.uiStateManager.updateState(window.uiStateManager.states.ERROR);
      }
    } catch (e) {
      console.warn('Error updating UI state:', e);
    }
    
    // Show appropriate error message
    if (error.message.includes('API key')) {
      replyElement.textContent = 'üîë API key missing or invalid. Click ‚öôÔ∏è to set your API key.';
      setTimeout(showApiKeyDialog, 1000);
    } else if (error.message.includes('rate') || error.message.includes('limit')) {
      replyElement.textContent = '‚è≥ Rate limit exceeded. Please wait a moment and try again.';
    } else if (error.message.includes('model')) {
      replyElement.textContent = `‚ö†Ô∏è Model not available. The ${appState.selectedModel} model might not be accessible.`;
    } else {
      replyElement.textContent = '‚ùå Error: ' + error.message;
    }
  }
}

// Function to generate response using OpenAI API
async function generateOpenAIResponse(text, model, systemPrompt, replyElement) {
  try {
    // Get API key
    const apiKey = localStorage.getItem('openai_api_key');
    
    if (!apiKey) {
      throw new Error('OpenAI API key missing');
    }
    
    // Make API request
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: model,
        messages: [
          {
            role: 'system',
            content: systemPrompt
          },
          {
            role: 'user',
            content: `Prospect said: "${text}". Reply with ONE persuasive rebuttal that's witty but professional. Keep it under 15 words.`
          }
        ]
      })
    });
    
    // Handle errors
    if (!response.ok) {
      let errorMessage = response.statusText;
      try {
        const errorData = await response.json();
        console.error("OpenAI API error:", errorData);
        if (errorData.error && errorData.error.message) {
          errorMessage = errorData.error.message;
        } else if (errorData.error) {
          errorMessage = JSON.stringify(errorData.error);
        } else if (errorData.message) {
          errorMessage = errorData.message;
        }
      } catch (e) {
        console.error("Failed to parse error response:", e);
      }
      throw new Error(errorMessage);
    }
    
    // Process successful response
    const data = await response.json();
    console.log("OpenAI API response:", data);
    
    // OpenAI API response format
    const reply = data.choices[0]?.message?.content || "No response from OpenAI";
    
    // Remove loading indicator and show reply
    replyElement.classList.remove('pulsing');
    replyElement.textContent = reply;
    
    // Return the reply to be added to history
    return reply;
  } catch (error) {
    console.error("OpenAI API error:", error);
    replyElement.classList.remove('pulsing');
    replyElement.textContent = `‚ùå Error using OpenAI: ${error.message}`;
    throw error;
  }
}

// Handle speech recognition errors and end events
r.onerror = e => console.log('Speech error:', e);
r.onend = () => {
  if (on) {
    // Auto-restart if recording should be on
    r.start();
  }
};
</script>

<footer class="footer">
  <a href="https://myaiadvantage.com/" target="_blank" rel="noopener">Visit myaiadvantage.com</a>
</footer>

<!-- Include utils.js for UIStateManager and other utilities -->
<script src="utils.js"></script>