<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Transcribe n Vibe</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Prompt:wght@300;400;500;600&display=swap" rel="stylesheet">
<style>
  :root {
    /* Primary Brand Colors */
    --beige: #E3E2E3;
    --lighter-gray: #454554;
    --darker-gray: #343541;
    --smart-green: #0EA27F;
    
    /* Secondary Brand Colors */
    --action-yellow: #FEDF0A;
    --smart-blue: #3536DF;
    --creative-purple: #41297D;
    --rebel-orange: #FE524E;
    
    /* UI Mapping */
    --bg-color: var(--beige);
    --text-color: var(--darker-gray);
    --primary-color: var(--smart-green);
    --primary-hover: var(--creative-purple);
    --secondary-bg: #f8f9fa;
    --border-color: var(--lighter-gray);
    --shadow-color: rgba(0, 0, 0, 0.1);
    --accent-color: var(--action-yellow);
    --radius: 12px;
    --inner-radius: 8px;
  }
  
  .dark-mode {
    --bg-color: var(--darker-gray);
    --text-color: var(--beige);
    --primary-color: var(--smart-green);
    --primary-hover: var(--smart-blue);
    --secondary-bg: var(--lighter-gray);
    --border-color: #2d2d2d;
    --shadow-color: rgba(0, 0, 0, 0.5);
    --accent-color: var(--action-yellow);
  }
  
  .dark-mode .logo {
    filter: invert(1);
  }
  
  body { 
    font-family: 'Prompt', -apple-system, BlinkMacSystemFont, sans-serif; 
    max-width: 650px; 
    margin: 20px auto; 
    line-height: 1.6; 
    background-color: var(--bg-color);
    color: var(--text-color);
    transition: all 0.3s ease;
    padding: 0 20px;
    font-size: 15px;
  }
  
  .logo-container {
    text-align: center;
    margin-bottom: 20px;
  }
  
  .logo {
    max-width: 280px;
    height: auto;
  }
  
  .header-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
  }
  
  .controls {
    display: flex;
    gap: 10px;
  }
  
  button { 
    padding: 10px 16px; 
    background: var(--primary-color); 
    color: white; 
    border: none; 
    border-radius: var(--inner-radius); 
    cursor: pointer; 
    font-family: 'Prompt', sans-serif;
    font-weight: 500;
    letter-spacing: 0.01em;
    transition: all 0.2s ease;
    font-size: 14px;
  }
  
  button:hover { 
    background: var(--primary-hover);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }
  
  .controls button {
    padding: 8px 12px;
    font-size: 1.1rem;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  pre { 
    background: var(--secondary-bg); 
    padding: 15px; 
    border-radius: var(--inner-radius); 
    white-space: pre-wrap; 
    margin-top: 15px;
    border: 1px solid var(--border-color);
    transition: background-color 0.3s;
    font-size: 14px;
    line-height: 1.6;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
  }
  
  h2, h3 {
    font-family: 'Montserrat', sans-serif;
    font-weight: 600;
    color: var(--primary-color);
  }
  
  /* Dialog styles */
  .dialog {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  
  .dialog-content {
    background-color: var(--bg-color);
    padding: 20px;
    border-radius: 5px;
    width: 80%;
    max-width: 400px;
    box-shadow: 0 2px 10px var(--shadow-color);
  }
  
  .dialog input {
    width: 100%;
    padding: 10px 12px;
    margin: 8px 0 16px;
    border: 1px solid var(--border-color);
    border-radius: var(--inner-radius);
    background-color: var(--bg-color);
    color: var(--text-color);
    font-size: 14px;
    transition: border-color 0.2s;
  }
  
  .dialog input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(14, 162, 127, 0.2);
  }
  
  .api-key-section {
    margin-bottom: 8px;
  }
  
  .api-key-section label {
    display: block;
    margin-bottom: 4px;
    font-weight: 500;
    font-size: 14px;
  }
  
  .dialog-buttons {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 15px;
  }
  
  .info-text {
    font-size: 14px;
    opacity: 0.8;
  }
  
  
  #api-key-status {
    margin-top: 10px;
    font-size: 14px;
    min-height: 20px;
  }
  
  .hidden {
    display: none;
  }
  
  @keyframes pulse {
    0% { opacity: 0.6; }
    50% { opacity: 1; }
    100% { opacity: 0.6; }
  }
  
  .pulsing {
    animation: pulse 1.5s infinite;
  }
  
  /* App description */
  .app-description {
    margin: -5px 0 20px;
    font-size: 15px;
    color: var(--text-color);
    opacity: 0.8;
  }

  /* Model selector styles */
  .options-row {
    display: flex;
    align-items: center;
    gap: 18px;
    margin-bottom: 18px;
    background: var(--secondary-bg);
    padding: 14px 18px;
    border-radius: var(--radius);
    box-shadow: 0 2px 8px rgba(0,0,0,0.04);
  }
  
  .recording-controls {
    display: flex;
    align-items: center;
  }
  
  .record-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
    padding: 12px 18px;
    background-color: var(--primary-color);
    transition: all 0.3s ease;
    border-radius: 28px;
    box-shadow: 0 4px 12px rgba(14, 162, 127, 0.25);
  }
  
  .record-btn:hover {
    transform: translateY(-2px);
    background-color: var(--primary-hover);
    box-shadow: 0 6px 16px rgba(65, 41, 125, 0.35);
  }
  
  .record-btn.active {
    background-color: var(--rebel-orange);
    box-shadow: 0 4px 12px rgba(254, 82, 78, 0.25);
  }
  
  .record-btn.active:hover {
    box-shadow: 0 6px 16px rgba(254, 82, 78, 0.35);
  }
  
  #end-transcription {
    background-color: var(--smart-blue);
    box-shadow: 0 4px 12px rgba(53, 54, 223, 0.25);
    margin-left: 8px;
  }
  
  #end-transcription:hover {
    background-color: var(--creative-purple);
    box-shadow: 0 6px 16px rgba(65, 41, 125, 0.35);
  }
  
  .model-selector {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  select {
    padding: 8px 12px;
    border-radius: var(--inner-radius);
    border: 1px solid var(--border-color);
    background-color: var(--bg-color);
    color: var(--text-color);
    font-family: 'Prompt', sans-serif;
    font-size: 14px;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%230EA27F' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    padding-right: 32px;
    cursor: pointer;
    transition: border-color 0.2s;
  }
  
  select:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(14, 162, 127, 0.2);
  }
  
  .transcription-box,
  .response-box {
    margin: 18px 0;
    border-radius: var(--radius);
    border: 1px solid var(--border-color);
    background-color: var(--secondary-bg);
    padding: 18px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    transition: all 0.3s ease;
  }
  
  .transcription-box:hover,
  .response-box:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
  }
  
  .transcription-box {
    border-left: 4px solid var(--smart-blue);
  }
  
  .response-box {
    border-left: 4px solid var(--smart-green);
  }
  
  .response-container {
    margin: 18px 0;
  }
  
  .response-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  
  .response-header .box-label {
    margin-bottom: 0;
  }
  
  .box-label {
    font-family: 'Montserrat', sans-serif;
    font-weight: 600;
    margin-bottom: 12px;
    color: var(--primary-color);
    font-size: 15px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  
  /* System prompt styles */
  .system-prompt-container {
    margin: 20px 0;
    padding: 18px;
    background-color: var(--secondary-bg);
    border-radius: var(--radius);
    border: 1px solid var(--border-color);
    border-left: 4px solid var(--creative-purple);
    box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    transition: all 0.3s ease;
  }
  
  .system-prompt-container:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
  }
  
  .prompt-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  
  .prompt-header label {
    font-weight: bold;
  }
  
  .preset-controls {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  
  .preset-controls button {
    padding: 6px 10px;
    font-size: 0.9rem;
  }
  
  #save-as-preset {
    font-size: 0.85rem;
  }
  
  #manage-presets {
    padding: 4px 8px;
    font-size: 1rem;
  }
  
  textarea {
    width: calc(100% - 20px);
    padding: 12px 10px;
    border-radius: var(--inner-radius);
    border: 1px solid var(--border-color);
    margin-bottom: 10px;
    background-color: var(--bg-color);
    color: var(--text-color);
    font-family: 'Prompt', sans-serif;
    resize: vertical;
    font-size: 14px;
    transition: border-color 0.2s ease;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05) inset;
    line-height: 1.5;
  }
  
  textarea:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(14, 162, 127, 0.2);
  }
  
  /* Preset management styles */
  .preset-list {
    margin: 15px 0;
    max-height: 300px;
    overflow-y: auto;
  }
  
  .preset-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    background-color: var(--bg-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    margin-bottom: 8px;
  }
  
  .preset-name {
    font-weight: bold;
  }
  
  .preset-actions {
    display: flex;
    gap: 5px;
  }
  
  .preset-actions button {
    padding: 4px 8px;
    font-size: 0.8rem;
  }
  
  /* History list styles */
  .history-container {
    margin-top: 30px;
  }
  
  .history-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  
  .clear-btn {
    padding: 6px 12px;
    font-size: 0.85rem;
    background-color: var(--rebel-orange);
  }
  
  .clear-btn:hover {
    background-color: #e63e39;
  }
  
  .history-list {
    margin-top: 10px;
  }
  
  .history-item {
    padding: 15px;
    background-color: var(--secondary-bg);
    border-radius: 5px;
    border: 1px solid var(--border-color);
    margin-bottom: 10px;
  }
  
  .history-item-objection {
    font-size: 0.85rem;
    opacity: 0.8;
    margin-bottom: 8px;
  }
  
  .history-item-response {
    font-weight: bold;
  }
  
  .history-item-meta {
    display: flex;
    justify-content: space-between;
    margin-top: 10px;
    font-size: 0.8rem;
    color: var(--text-color);
    opacity: 0.7;
  }
  
  .footer {
    margin-top: 40px;
    padding: 15px 0;
    text-align: center;
    border-top: 1px solid var(--border-color);
  }
  
  .footer a {
    color: var(--primary-color);
    text-decoration: none;
    font-weight: 500;
    transition: color 0.2s ease;
  }
  
  .footer a:hover {
    color: var(--primary-hover);
    text-decoration: underline;
  }
</style>

<div class="logo-container">
  <img src="Logo black.png" alt="AI Advantage Logo" class="logo">
</div>
<div class="header-controls">
  <h2>Transcribe n Vibe</h2>
  <div class="controls">
    <button id="theme-toggle" title="Toggle dark mode">🌓</button>
    <button id="settings-btn" title="Settings">⚙️</button>
  </div>
</div>
<div class="app-description">
  <p>Record objections and get AI-powered comeback responses in real-time</p>
</div>

<div class="options-row">
  <div class="recording-controls">
    <button id="toggle" class="record-btn">
      <span id="status-dot"></span>🎤 Start Listening
    </button>
    <div id="visualizer-container" style="margin-left: 10px; width: 120px; height: 30px; display: none; align-items: center; justify-content: center;"></div>
  </div>
</div>

<div class="transcription-box">
  <p class="box-label">🎙️ Transcription:</p>
  <pre id="lastObjection">Your speech will appear here...</pre>
</div>

<div class="system-prompt-container">
  <div class="prompt-header">
    <label for="system-prompt">Prompt:</label>
    <div class="preset-controls">
      <select id="preset-select">
        <option value="">-- Choose Preset --</option>
        <option value="executive-reframer">Executive Reframer</option>
        <option value="negotiation">Negotiation Expert</option>
      </select>
      <button id="save-as-preset" title="Save as new preset">Save As+</button>
      <button id="manage-presets" title="Manage presets">⋮</button>
    </div>
  </div>
  <textarea id="system-prompt" rows="3">You are a C-suite communication strategist specializing in reframing challenges as opportunities. Craft concise, authoritative responses that acknowledge objections while shifting perspective toward mutual benefit. Your goal is to maintain leadership presence while turning potential conflicts into collaborative solutions.</textarea>
  <button id="save-prompt">Save Prompt</button>
</div>

<div class="response-container">
  <div class="response-header">
    <p class="box-label">💡 AI Response:</p>
    <div class="model-selector">
      <label for="model-select">Model:</label>
      <select id="model-select">
        <option value="gpt-4o">GPT-4o</option>
        <option value="gpt-4o-mini">GPT-4o Mini</option>
        <option value="o1-preview">O1 Preview</option>
        <option value="o1-mini">O1 Mini</option>
      </select>
    </div>
  </div>
  <div class="response-box">
    <pre id="reply">Responses will appear here...</pre>
  </div>
</div>

<!-- Preset Management Dialog -->
<div id="preset-dialog" class="dialog hidden">
  <div class="dialog-content">
    <h3>Manage Prompt Presets</h3>
    <div id="preset-list" class="preset-list">
      <!-- Presets will be loaded here -->
    </div>
    <div class="dialog-buttons">
      <button id="preset-dialog-close">Close</button>
    </div>
  </div>
</div>

<!-- New Preset Dialog -->
<div id="new-preset-dialog" class="dialog hidden">
  <div class="dialog-content">
    <h3>Save as New Preset</h3>
    <label for="new-preset-name">Preset Name:</label>
    <input type="text" id="new-preset-name" placeholder="Enter a name for this preset">
    <div class="dialog-buttons">
      <button id="new-preset-cancel">Cancel</button>
      <button id="new-preset-save">Save</button>
    </div>
    <p id="new-preset-status"></p>
  </div>
</div>

<div class="history-container">
  <div class="history-header">
    <h3>Response History</h3>
    <button id="clear-history" class="clear-btn" title="Clear all history">Clear History</button>
  </div>
  <div id="history-list" class="history-list"></div>
</div>

<!-- API Key Dialog -->
<div id="api-key-dialog" class="dialog hidden">
  <div class="dialog-content">
    <h3>GitHub Token</h3>
    <p class="info-text">Your GitHub token is stored locally in your browser.</p>
    
    <div class="api-key-section">
      <label for="github-token-input">GitHub Token:</label>
      <input type="password" id="github-token-input" placeholder="ghp_..." />
    </div>
    
    <div class="dialog-buttons">
      <button id="api-key-save">Save</button>
      <button id="api-key-cancel">Cancel</button>
    </div>
    <p id="api-key-status"></p>
  </div>
</div>

<script>
// Initialize Speech Recognition
const Speech = window.SpeechRecognition || window.webkitSpeechRecognition;
const r = new Speech();
r.continuous = true;
r.interimResults = false;
let on = false;
let lastTranscript = '';

// Initialize app state
const appState = {
  responseHistory: [],
  systemPrompt: 'You are a C-suite communication strategist specializing in reframing challenges as opportunities. Craft concise, authoritative responses that acknowledge objections while shifting perspective toward mutual benefit. Your goal is to maintain leadership presence while turning potential conflicts into collaborative solutions.',
  selectedModel: 'gpt-4o',
  presets: {
    'executive-reframer': {
      name: 'Executive Reframer',
      prompt: 'You are a C-suite communication strategist specializing in reframing challenges as opportunities. Craft concise, authoritative responses that acknowledge objections while shifting perspective toward mutual benefit. Your goal is to maintain leadership presence while turning potential conflicts into collaborative solutions.'
    },
    'negotiation': {
      name: 'Negotiation Expert',
      prompt: 'You are a skilled negotiation expert. Generate concise, tactical responses that redirect objections while building value. Focus on finding common ground, addressing concerns empathetically, and guiding toward agreement. Use data and logical framing to strengthen your position. Keep responses under 15 words and maintain a persuasive yet collaborative tone.'
    }
  }
};

// Initialize theme and settings
let audioProcessor = null;

document.addEventListener('DOMContentLoaded', () => {
  // Initialize audio processor if available
  if (typeof AudioProcessor === 'function') {
    try {
      audioProcessor = new AudioProcessor();
    } catch (e) {
      console.error('Error initializing AudioProcessor:', e);
    }
  }
  
  // Initialize UI state manager with error handling
  try {
    window.uiStateManager = new UIStateManager();
    console.log('UIStateManager initialized successfully');
  } catch (e) {
    console.error('Error initializing UIStateManager:', e);
  }
  
  // Load saved state
  loadSavedState();
  
  // No API key checks needed up front
  
  // Setup dark mode
  const savedTheme = localStorage.getItem('theme_mode');
  if (savedTheme === 'dark') {
    document.body.classList.add('dark-mode');
    
    // Set the toggle icon text
    const themeToggle = document.getElementById('theme-toggle');
    if (themeToggle) {
      themeToggle.textContent = '🌓';
    }
  }
  
  // Set up event listeners with error handling
  const setupEventListeners = () => {
    try {
      // Theme toggle
      const themeToggle = document.getElementById('theme-toggle');
      if (themeToggle) {
        themeToggle.addEventListener('click', toggleTheme);
        console.log("Theme toggle button listener added");
      }
      
      // Settings button
      const settingsBtn = document.getElementById('settings-btn');
      if (settingsBtn) {
        settingsBtn.addEventListener('click', showApiKeyDialog);
        console.log("Settings button listener added");
      }
      
      // API key dialog buttons
      const apiKeySave = document.getElementById('api-key-save');
      if (apiKeySave) {
        apiKeySave.addEventListener('click', saveApiKey);
      }
      
      const apiKeyCancel = document.getElementById('api-key-cancel');
      if (apiKeyCancel) {
        apiKeyCancel.addEventListener('click', hideApiKeyDialog);
      }
      
      // Recording toggle
      const toggleBtn = document.getElementById('toggle');
      if (toggleBtn) {
        toggleBtn.addEventListener('click', toggleRecording);
        console.log("Toggle recording button listener added");
      }
      
      // Save prompt button
      const savePromptBtn = document.getElementById('save-prompt');
      if (savePromptBtn) {
        savePromptBtn.addEventListener('click', saveSystemPrompt);
      }
      
      // Model select
      const modelSelect = document.getElementById('model-select');
      if (modelSelect) {
        modelSelect.addEventListener('change', updateSelectedModel);
      }
    } catch (error) {
      console.error("Error setting up event listeners:", error);
    }
  };
  
  // Set up event listeners immediately and also with a small delay to ensure DOM is ready
  setupEventListeners();
  setTimeout(setupEventListeners, 500);
  
  // Preset management listeners
  try {
    const presetSelect = document.getElementById('preset-select');
    if (presetSelect) {
      presetSelect.addEventListener('change', loadSelectedPreset);
    }
    
    const saveAsPreset = document.getElementById('save-as-preset');
    if (saveAsPreset) {
      saveAsPreset.addEventListener('click', showNewPresetDialog);
    }
    
    const managePresets = document.getElementById('manage-presets');
    if (managePresets) {
      managePresets.addEventListener('click', showPresetManagerDialog);
    }
    
    const presetDialogClose = document.getElementById('preset-dialog-close');
    if (presetDialogClose) {
      presetDialogClose.addEventListener('click', hidePresetManagerDialog);
    }
    
    const newPresetCancel = document.getElementById('new-preset-cancel');
    if (newPresetCancel) {
      newPresetCancel.addEventListener('click', hideNewPresetDialog);
    }
    
    const newPresetSave = document.getElementById('new-preset-save');
    if (newPresetSave) {
      newPresetSave.addEventListener('click', saveNewPreset);
    }
    
    // History management
    const clearHistory = document.getElementById('clear-history');
    if (clearHistory) {
      clearHistory.addEventListener('click', clearResponseHistory);
    }
  } catch (error) {
    console.error("Error setting up preset/history listeners:", error);
  }
  
  // Close dialogs with Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      try {
        const apiKeyDialog = document.getElementById('api-key-dialog');
        const presetDialog = document.getElementById('preset-dialog');
        const newPresetDialog = document.getElementById('new-preset-dialog');
        
        if (apiKeyDialog && !apiKeyDialog.classList.contains('hidden')) {
          hideApiKeyDialog();
        } else if (presetDialog && !presetDialog.classList.contains('hidden')) {
          hidePresetManagerDialog();
        } else if (newPresetDialog && !newPresetDialog.classList.contains('hidden')) {
          hideNewPresetDialog();
        }
      } catch (error) {
        console.error("Error handling Escape key:", error);
      }
    }
  });
  
  // Render initial UI
  renderHistoryList();
  renderPresetList();
});

// Load app state from localStorage
function loadSavedState() {
  // Load system prompt
  const savedPrompt = localStorage.getItem('system_prompt');
  if (savedPrompt) {
    appState.systemPrompt = savedPrompt;
    document.getElementById('system-prompt').value = savedPrompt;
  }
  
  // Load selected model
  const savedModel = localStorage.getItem('selected_model');
  if (savedModel) {
    appState.selectedModel = savedModel;
    document.getElementById('model-select').value = savedModel;
  }
  
  // Load GitHub token
  const githubToken = localStorage.getItem('github_token') || '';
  
  // Load response history
  const savedHistory = localStorage.getItem('response_history');
  if (savedHistory) {
    try {
      appState.responseHistory = JSON.parse(savedHistory);
    } catch (e) {
      console.error('Error parsing saved history:', e);
      appState.responseHistory = [];
    }
  }
  
  // Load custom presets
  const savedPresets = localStorage.getItem('custom_presets');
  if (savedPresets) {
    try {
      const customPresets = JSON.parse(savedPresets);
      // Merge custom presets with default presets
      appState.presets = { ...appState.presets, ...customPresets };
      // Update the preset dropdown options
      setTimeout(updatePresetOptions, 0);
    } catch (e) {
      console.error('Error parsing saved presets:', e);
    }
  } else {
    // Make sure we have all default presets in the dropdown
    setTimeout(updatePresetOptions, 0);
  }
}

// Preset management functions
function renderPresetList() {
  const presetList = document.getElementById('preset-list');
  presetList.innerHTML = '';
  
  // Create preset items
  Object.entries(appState.presets).forEach(([id, preset]) => {
    const presetItem = document.createElement('div');
    presetItem.className = 'preset-item';
    
    const nameSpan = document.createElement('span');
    nameSpan.className = 'preset-name';
    nameSpan.textContent = preset.name;
    
    const actions = document.createElement('div');
    actions.className = 'preset-actions';
    
    const loadBtn = document.createElement('button');
    loadBtn.textContent = 'Load';
    loadBtn.addEventListener('click', () => {
      loadPreset(id);
      hidePresetManagerDialog();
    });
    
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete';
    
    // Don't allow deleting the default presets
    if (['executive-reframer', 'negotiation'].includes(id)) {
      deleteBtn.disabled = true;
      deleteBtn.title = 'Cannot delete default presets';
    } else {
      deleteBtn.addEventListener('click', () => deletePreset(id));
    }
    
    actions.appendChild(loadBtn);
    actions.appendChild(deleteBtn);
    
    presetItem.appendChild(nameSpan);
    presetItem.appendChild(actions);
    
    presetList.appendChild(presetItem);
  });
}

// Load a preset by ID
function loadPreset(presetId) {
  const preset = appState.presets[presetId];
  if (preset) {
    document.getElementById('system-prompt').value = preset.prompt;
    appState.systemPrompt = preset.prompt;
    localStorage.setItem('system_prompt', preset.prompt);
    
    // Update the dropdown selection
    document.getElementById('preset-select').value = presetId;
  }
}

// Load selected preset from dropdown
function loadSelectedPreset(e) {
  const presetId = e.target.value;
  if (presetId) {
    loadPreset(presetId);
  }
}

// Delete a preset
function deletePreset(presetId) {
  if (confirm(`Delete the preset "${appState.presets[presetId].name}"?`)) {
    // Remove from state
    delete appState.presets[presetId];
    
    // Filter out default presets and save custom ones
    const customPresets = {};
    Object.entries(appState.presets).forEach(([id, preset]) => {
      if (!['executive-reframer', 'negotiation'].includes(id)) {
        customPresets[id] = preset;
      }
    });
    
    // Save custom presets to localStorage
    localStorage.setItem('custom_presets', JSON.stringify(customPresets));
    
    // Update UI
    renderPresetList();
  }
}

// Show preset manager dialog
function showPresetManagerDialog() {
  renderPresetList();
  document.getElementById('preset-dialog').classList.remove('hidden');
}

// Hide preset manager dialog
function hidePresetManagerDialog() {
  document.getElementById('preset-dialog').classList.add('hidden');
}

// Show new preset dialog
function showNewPresetDialog() {
  document.getElementById('new-preset-name').value = '';
  document.getElementById('new-preset-status').textContent = '';
  document.getElementById('new-preset-dialog').classList.remove('hidden');
}

// Hide new preset dialog
function hideNewPresetDialog() {
  document.getElementById('new-preset-dialog').classList.add('hidden');
}

// Save a new preset
function saveNewPreset() {
  const nameInput = document.getElementById('new-preset-name');
  const statusElement = document.getElementById('new-preset-status');
  const name = nameInput.value.trim();
  
  if (!name) {
    statusElement.textContent = 'Please enter a name for the preset';
    statusElement.style.color = '#dc3545';
    return;
  }
  
  // Create a unique ID based on the name
  const id = 'custom-' + name.toLowerCase().replace(/[^a-z0-9]/g, '-');
  
  // Check if ID already exists
  if (appState.presets[id]) {
    statusElement.textContent = 'A preset with this name already exists';
    statusElement.style.color = '#dc3545';
    return;
  }
  
  // Create the new preset
  const newPreset = {
    name: name,
    prompt: document.getElementById('system-prompt').value
  };
  
  // Add to state
  appState.presets[id] = newPreset;
  
  // Filter out default presets and save custom ones
  const customPresets = {};
  Object.entries(appState.presets).forEach(([presetId, preset]) => {
    if (!['executive-reframer', 'negotiation'].includes(presetId)) {
      customPresets[presetId] = preset;
    }
  });
  
  // Save to localStorage
  localStorage.setItem('custom_presets', JSON.stringify(customPresets));
  
  // Update the preset dropdown options
  updatePresetOptions();
  
  // Show success message
  statusElement.textContent = 'Preset saved successfully';
  statusElement.style.color = '#28a745';
  
  // Close dialog after delay
  setTimeout(hideNewPresetDialog, 1500);
}

// Update preset dropdown options
function updatePresetOptions() {
  const select = document.getElementById('preset-select');
  
  // Clear existing options except the default one
  while (select.options.length > 1) {
    select.remove(1);
  }
  
  // Add all presets as options
  Object.entries(appState.presets).forEach(([id, preset]) => {
    const option = document.createElement('option');
    option.value = id;
    option.textContent = preset.name;
    select.appendChild(option);
  });
}

// Save system prompt
function saveSystemPrompt() {
  const promptText = document.getElementById('system-prompt').value.trim();
  if (promptText) {
    appState.systemPrompt = promptText;
    localStorage.setItem('system_prompt', promptText);
    
    // Show a flash message
    const saveBtn = document.getElementById('save-prompt');
    const originalText = saveBtn.textContent;
    saveBtn.textContent = 'Saved!';
    saveBtn.style.backgroundColor = '#28a745';
    
    setTimeout(() => {
      saveBtn.textContent = originalText;
      saveBtn.style.backgroundColor = '';
    }, 1500);
  }
}

// Update selected model
function updateSelectedModel(e) {
  appState.selectedModel = e.target.value;
  localStorage.setItem('selected_model', appState.selectedModel);
}

// Toggle dark/light theme
function toggleTheme() {
  document.body.classList.toggle('dark-mode');
  const isDark = document.body.classList.contains('dark-mode');
  localStorage.setItem('theme_mode', isDark ? 'dark' : 'light');
  
  const themeToggle = document.getElementById('theme-toggle');
  if (themeToggle) {
    if (isDark) {
      themeToggle.textContent = '🌓';
    } else {
      themeToggle.textContent = '🌓';
    }
  }
}

// API Key dialog functions
function showApiKeyDialog() {
  const dialog = document.getElementById('api-key-dialog');
  const githubInput = document.getElementById('github-token-input');
  
  const githubToken = localStorage.getItem('github_token') || '';
  
  githubInput.value = githubToken;
  
  dialog.classList.remove('hidden');
  setTimeout(() => githubInput.focus(), 100);
}

function hideApiKeyDialog() {
  document.getElementById('api-key-dialog').classList.add('hidden');
}

function saveApiKey() {
  const githubInput = document.getElementById('github-token-input');
  const status = document.getElementById('api-key-status');
  
  const githubToken = githubInput.value.trim();
  let isValid = true;
  
  // Validate GitHub token if provided
  if (githubToken && !githubToken.startsWith('ghp_')) {
    status.textContent = 'Invalid GitHub token format. It should start with "ghp_"';
    status.style.color = '#dc3545';
    isValid = false;
  }
  
  if (isValid) {
    if (githubToken) {
      localStorage.setItem('github_token', githubToken);
    }
    
    status.textContent = 'GitHub token saved successfully!';
    status.style.color = '#28a745';
    setTimeout(hideApiKeyDialog, 1000);
  }
}

// Toggle recording function
function toggleRecording() {
  const button = document.getElementById('toggle');
  
  if (on) {
    r.stop();
    on = false;
    button.textContent = '🎤 Start Listening';
    button.classList.remove('active');
    document.getElementById('lastObjection').textContent = 'Your speech will appear here...';
    
    // Update UI state to ready with safe error handling
    try {
      if (window.uiStateManager && window.uiStateManager.states && window.uiStateManager.updateState) {
        window.uiStateManager.updateState(window.uiStateManager.states.READY);
      }
    } catch (e) {
      console.warn('Error updating UI state:', e);
    }
    
    // Stop visualizer when recording stops if available
    if (audioProcessor && typeof audioProcessor.stopVisualizer === 'function') {
      try {
        audioProcessor.stopVisualizer();
        // Hide the visualizer container
        const visualizerContainer = document.getElementById('visualizer-container');
        if (visualizerContainer) {
          visualizerContainer.style.display = 'none';
        }
      } catch (e) {
        console.error('Error stopping visualizer:', e);
      }
    }
  } else {
    // Start speech recognition
    try {
      r.start();
      on = true;
      button.textContent = '🛑 Stop Listening';
      button.classList.add('active');
      
      // Update UI state to listening with safe error handling
      try {
        if (window.uiStateManager && window.uiStateManager.states && window.uiStateManager.updateState) {
          window.uiStateManager.updateState(window.uiStateManager.states.LISTENING);
        }
      } catch (e) {
        console.warn('Error updating UI state:', e);
      }
      
      // Start audio context and visualizer if available
      if (audioProcessor && typeof audioProcessor.initAudioContext === 'function') {
        try {
          // Get audio stream for visualization
          navigator.mediaDevices.getUserMedia({ audio: true, video: false })
            .then(stream => {
              audioProcessor.initAudioContext()
                .then(() => {
                  const visualizerContainer = document.getElementById('visualizer-container');
                  if (visualizerContainer && typeof audioProcessor.setupVisualizer === 'function') {
                    // Make the container visible
                    visualizerContainer.style.display = 'flex';
                    audioProcessor.setupVisualizer(stream, visualizerContainer);
                  }
                })
                .catch(err => console.error('Failed to initialize audio context:', err));
            })
            .catch(err => console.error('Error accessing microphone:', err));
        } catch (e) {
          console.error('Error with audio processing:', e);
          // Continue with recording even if visualization fails
        }
      }
    } catch (e) {
      console.error('Error starting speech recognition:', e);
      alert('Failed to start speech recognition. Please try again.');
      
      // Update UI state to error with safe error handling
      try {
        if (window.uiStateManager && window.uiStateManager.states && window.uiStateManager.updateState) {
          window.uiStateManager.updateState(window.uiStateManager.states.ERROR);
        }
      } catch (e) {
        console.warn('Error updating UI state:', e);
      }
    }
  }
}

// Event handler for speech recognition results
r.onresult = async (e) => {
  const transcript = e.results[e.results.length-1][0].transcript.trim();
  document.getElementById('lastObjection').textContent = transcript;
  
  // If the transcript changed, generate a new response
  if (transcript !== lastTranscript) {
    lastTranscript = transcript;
    await generateResponse(transcript);
  }
};

// Render the history list
function renderHistoryList() {
  const historyList = document.getElementById('history-list');
  historyList.innerHTML = '';
  
  // Display history items from newest to oldest
  const sortedHistory = [...appState.responseHistory].reverse();
  
  sortedHistory.forEach(item => {
    const historyItem = document.createElement('div');
    historyItem.className = 'history-item';
    
    const objection = document.createElement('div');
    objection.className = 'history-item-objection';
    objection.textContent = '👂 ' + item.objection;
    
    const response = document.createElement('div');
    response.className = 'history-item-response';
    response.textContent = '💡 ' + item.response;
    
    const meta = document.createElement('div');
    meta.className = 'history-item-meta';
    
    const timestamp = document.createElement('span');
    timestamp.textContent = item.timestamp;
    
    const model = document.createElement('span');
    // Friendly display names for models
    let modelDisplay = item.model
      .replace('gpt-4o-2024-08-06', 'GPT-4o')
      .replace('gpt-4o-mini-2024-07-18', 'GPT-4o Mini');
    
    model.textContent = modelDisplay;
    
    meta.appendChild(timestamp);
    meta.appendChild(model);
    
    historyItem.appendChild(objection);
    historyItem.appendChild(response);
    historyItem.appendChild(meta);
    
    historyList.appendChild(historyItem);
  });
}

// Add a response to history
function addToHistory(objection, response, model) {
  const now = new Date();
  const timestamp = now.toLocaleTimeString();
  
  // Create history item
  const historyItem = {
    objection,
    response,
    model,
    timestamp
  };
  
  // Add to history
  appState.responseHistory.push(historyItem);
  
  // Limit history to 50 items
  if (appState.responseHistory.length > 50) {
    appState.responseHistory.shift();
  }
  
  // Save to localStorage
  localStorage.setItem('response_history', JSON.stringify(appState.responseHistory));
  
  // Update UI
  renderHistoryList();
}

// Clear response history
function clearResponseHistory() {
  if (confirm('Are you sure you want to clear all response history? This cannot be undone.')) {
    // Clear history in state
    appState.responseHistory = [];
    
    // Clear from localStorage
    localStorage.removeItem('response_history');
    
    // Update UI
    renderHistoryList();
    
    // Show confirmation
    const clearBtn = document.getElementById('clear-history');
    const originalText = clearBtn.textContent;
    clearBtn.textContent = 'Cleared!';
    
    setTimeout(() => {
      clearBtn.textContent = originalText;
    }, 1500);
  }
}

// Function to generate a response using OpenAI API
async function generateResponse(text) {
  const replyElement = document.getElementById('reply');
  
  // Show loading indicator
  replyElement.textContent = 'Thinking...';
  replyElement.classList.add('pulsing');
  
  // Update UI state to processing with safe error handling
  try {
    if (window.uiStateManager && window.uiStateManager.states && window.uiStateManager.updateState) {
      window.uiStateManager.updateState(window.uiStateManager.states.PROCESSING);
    }
  } catch (e) {
    console.warn('Error updating UI state:', e);
  }
  
  try {
    // Get selected model
    const model = appState.selectedModel;
    
    // Get system prompt
    const systemPrompt = appState.systemPrompt;
    
    // Generate response using GitHub Inference API
    const reply = await generateGitHubResponse(text, model, systemPrompt, replyElement);
    
    // Add to history after successful response
    addToHistory(text, reply, model);
    
    // Update UI state back to listening if still recording with safe error handling
    try {
      if (window.uiStateManager && window.uiStateManager.states && window.uiStateManager.updateState) {
        if (on) {
          window.uiStateManager.updateState(window.uiStateManager.states.LISTENING);
        } else {
          window.uiStateManager.updateState(window.uiStateManager.states.READY);
        }
      }
    } catch (e) {
      console.warn('Error updating UI state:', e);
    }
    
  } catch (error) {
    // Handle errors
    console.error('Error:', error);
    replyElement.classList.remove('pulsing');
    
    // Update UI state to error with safe error handling
    try {
      if (window.uiStateManager && window.uiStateManager.states && window.uiStateManager.updateState) {
        window.uiStateManager.updateState(window.uiStateManager.states.ERROR);
      }
    } catch (e) {
      console.warn('Error updating UI state:', e);
    }
    
    // Show appropriate error message
    if (error.message.includes('token') || error.message.includes('API key')) {
      replyElement.textContent = '🔑 GitHub token missing or invalid. Click ⚙️ to set your GitHub token.';
      setTimeout(showApiKeyDialog, 1000);
    } else if (error.message.includes('rate') || error.message.includes('limit')) {
      replyElement.textContent = '⏳ Rate limit exceeded. Please wait a moment and try again.';
    } else if (error.message.includes('model')) {
      replyElement.textContent = `⚠️ Model not available. The ${appState.selectedModel} model might not be accessible.`;
    } else {
      replyElement.textContent = '❌ Error: ' + error.message;
    }
  }
}

// Function to generate response using GitHub Inference API
async function generateGitHubResponse(text, model, systemPrompt, replyElement) {
  try {
    // Get GitHub token
    const githubToken = localStorage.getItem('github_token');
    
    if (!githubToken) {
      throw new Error('GitHub token missing');
    }
    
    // GitHub Models API endpoint 
    const endpoint = 'https://models.inference.ai.azure.com/chat/completions';
    
    // Make API request
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${githubToken}`
      },
      body: JSON.stringify({
        model: model,
        messages: [
          {
            role: 'system',
            content: systemPrompt
          },
          {
            role: 'user',
            content: `Prospect said: "${text}". Reply with ONE persuasive rebuttal that's witty but professional. Keep it under 15 words.`
          }
        ],
        temperature: 1.0,
        top_p: 1.0
      })
    });
    
    // Handle errors
    if (!response.ok) {
      let errorMessage = response.statusText;
      try {
        const errorData = await response.json();
        console.error("GitHub API error:", errorData);
        if (errorData.error && errorData.error.message) {
          errorMessage = errorData.error.message;
        } else if (errorData.error) {
          errorMessage = JSON.stringify(errorData.error);
        } else if (errorData.message) {
          errorMessage = errorData.message;
        }
      } catch (e) {
        console.error("Failed to parse error response:", e);
      }
      throw new Error(errorMessage);
    }
    
    // Process successful response
    const data = await response.json();
    console.log("GitHub API response:", data);
    
    // GitHub API response format (same as OpenAI)
    const reply = data.choices[0]?.message?.content || "No response from GitHub";
    
    // Remove loading indicator and show reply
    replyElement.classList.remove('pulsing');
    replyElement.textContent = reply;
    
    // Return the reply to be added to history
    return reply;
  } catch (error) {
    console.error("GitHub API error:", error);
    replyElement.classList.remove('pulsing');
    replyElement.textContent = `❌ Error using GitHub: ${error.message}`;
    throw error;
  }
}

// Handle speech recognition errors and end events
r.onerror = e => console.log('Speech error:', e);
r.onend = () => {
  if (on) {
    // Auto-restart if recording should be on
    r.start();
  }
};
</script>

<footer class="footer">
  <a href="https://myaiadvantage.com/" target="_blank" rel="noopener">Visit myaiadvantage.com</a>
</footer>

<!-- Include utils.js for UIStateManager and other utilities -->
<script src="utils.js"></script>